SELECT * FROM accounts
WHERE primary_poc IS NOT NULL;

SELECT COUNT(*) AS order_count
FROM orders
WHERE occurred_at >= '2016-12-01'
	AND occurred_at < '2017-12-01';
	
SELECT * FROM orders;

SELECT SUM(standard_amt_usd/(standard_qty+0.01)) AS std_unit
FROM orders;

SELECT SUM(standard_amt_usd)/SUM(standard_qty) AS standard_price_per_unit
FROM orders;

SELECT occurred_at AS earliest_order
FROM orders
ORDER BY occurred_at ASC
LIMIT 1;
--The above syntax can also be written as--
SELECT MIN (occurred_at) AS earliest_order
FROM orders;

/*Find the mean (AVERAGE) amount spent per order on each paper type, as well
as the mean amount of each paper type purchased per order. Your final answer
should have 6 values - one for each paper type for the average number of sales,
as well as the average amount.*/
SELECT
	AVG(standard_qty) AS mean_std,
	AVG(gloss_qty) AS mean_gls,
	AVG(poster_qty) AS mean_pst,
	AVG(standard_amt_usd) AS mean_amt_std,
	AVG(gloss_amt_usd) AS mean_amt_gls,
	AVG(poster_amt_usd) AS mean_amt_pst
FROM orders;
	
--GROUP BY EXERCISES
/*1. Which account (by name) placed the earliest order?
Your solution should have the account name and the date of the order.*/
SELECT
	a.name AS account_name,
	o.occurred_at AS earliest_order
FROM accounts a
JOIN orders o
ON a.id = o.account_id
ORDER BY 2 ASC
LIMIT 1;

/*2. Find the total sales in usd for each account.
You should include two columns: the total sales for each company's orders in usd and the company name*/
SELECT
	a.name AS company_name,
	SUM(o.total_amt_usd) AS total_sales
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC;

/*3. Via what channel did the most recent (latest) web_event occur,
which account was associated with this web_event?
Your query should return only three values - the date, channel, and account name.*/

SELECT 
	wb.occurred_at AS latest_web_event,
	wb.channel AS channel,
	a.name AS account_name
FROM web_events wb
JOIN accounts a
ON wb.account_id = a.id
ORDER BY 1 DESC
LIMIT 1;

/*4. Find the total number of times each type of channel from the web_events was used.
Your final table should have two columns: the channel & the number of times the channel was used.*/

SELECT
	COUNT (*) AS channel_frq,
	channel
FROM web_events
GROUP BY 2
ORDER BY 1;

/*5. Who was the primary contact associated with the earliest web_event?*/

SELECT
	a.primary_poc AS primary_poc,
	wb.occurred_at AS earliest_wb
FROM accounts a
JOIN web_events wb
ON a.id = wb.account_id
ORDER BY earliest_wb ASC
LIMIT 1;

/*6. What was the smallest order placed by each account in terms of total usd.
Provide only two columns - the account name and the total usd.
Order from smallest dollar amounts to largest.*/

SELECT
	a.name AS account_name,
	MIN (o.total_amt_usd) AS smallest_op
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 ASC;

/*7. Find the number of sales reps in each region.
Your final table should have two columns - the region and the number of sales_reps.
Order from fewest reps to most reps.*/

SELECT
	r.name AS region,
	COUNT (sr.name) AS num_sales_rep
FROM region r
JOIN sales_reps sr
ON r.id = sr.region_id
GROUP BY 1
ORDER BY 2;

/*8. For each account, determine the average amount of each type of paper they purchased across
their orders. Your result should have four columns: one for the account name and one for the
average quantity purchased for each of the paper types for each account.*/

SELECT
	a.name AS account_name,
	AVG (o.standard_qty) AS avg_std_qty,
	AVG (o.gloss_qty) AS avg_gls_qty,
	AVG (o.poster_qty) AS avg_pst_qty
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 1;

/*9. For each account, determine the average amount spent per order on each paper type.
Your result should have four columns: one for the account name and one for the average amount
spent on each paper type.*/

SELECT
	a.name AS account_name,
	AVG (o.standard_amt_usd) AS avg_std_amt,
	AVG (o.gloss_amt_usd) AS avg_gls_amt,
	AVG (o.poster_amt_usd) AS avg_pst_amt
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 1;
	
/*10. Determine the number of times a particular channel was used in the web_events table for
each sales rep. Your final table should have three columns: the name of the sales rep,
the channel, and the number of occurrences. Order your table with the highest number of
occurrences first.*/

SELECT
	sr.name AS sales_rep,
	wb.channel AS channel,
	COUNT (*) AS num_of_occurnc
FROM sales_reps sr
JOIN accounts a
ON sr.id = a.sales_rep_id
JOIN web_events wb
ON wb.account_id = a.id
GROUP BY 1,2
ORDER BY 3 DESC;

/*11. Determine the number of times a particular channel was used in the web_events table for
each region. Your final table should have three columns: the region name, the channel, and the
number of occurrences. Order your table with the highest number of occurrences first.*/

SELECT
	r.name AS region,
	wb.channel AS channel,
	COUNT (*) AS num_of_occurnc
FROM region r
JOIN sales_reps sr
ON r.id = sr.region_id
JOIN accounts a
ON a.sales_rep_id = sr.id
JOIN web_events wb
ON wb.account_id = a.id
GROUP BY 1,2
ORDER BY 3 DESC;

--DISTINCT EXCERCISES
/*1. Use DISTINCT to test if there are any accounts associated with more than one region.*/

SELECT
	a.name AS accounts,
	r.name AS region
FROM accounts a
JOIN sales_reps sr
ON a.sales_rep_id = sr.id
JOIN region r
ON r.id = sr.region_id
ORDER BY 1;

SELECT
	DISTINCT id,
	name
FROM accounts;
/*Both queries above retuned the same number of rows which shows that there are no accounts
associated with more than one region.*/

/*2. Have any sales reps worked on more than one account?*/

SELECT
	a.name AS accounts,
	sr.name AS sales_rep
FROM accounts a
JOIN sales_reps sr
ON a.sales_rep_id = sr.id;

SELECT
	DISTINCT id,
	name
FROM sales_reps;
/*Both queries above retuned different number of rows which shows each sales reps have worked
on more than one account.*/

--HAVING CLAUSE EXERCISE:
/*1. How many of the sales reps have more than 5 accounts that they manage?*/
SELECT COUNT (t1) 
FROM (SELECT
		sr.name AS sales_rep,
		COUNT (a.id) AS no_of_accts
	FROM sales_reps sr
	JOIN accounts a
	ON sr.id = a.sales_rep_id
	GROUP BY 1
	HAVING COUNT (a.id) > 5
	 ) t1;
--The query returned 34 rows. Hence, 34 sales reps have more than 5 accounts that they manage.

/* 2. How many accounts have more than 20 orders?*/
SELECT COUNT (t1)
FROM (SELECT
		a.id AS account_id,
		COUNT (o.id) AS order_id
	FROM accounts a
	JOIN orders o
	ON a.id = o.account_id
	GROUP BY 1
	HAVING COUNT (o.id) > 20
	ORDER BY 2 DESC) t1;
--The are 120 accounts with more than 20 orders.

/*3. Which account has the most orders?*/
SELECT
	a.name AS accoun_name,
	COUNT (o.id) AS num_of_orders
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC
LIMIT 1;
--Leucadia National has the most order

/*4. Which accounts spent more than 30,000 usd total across all orders?*/
SELECT
	a.name account_name,
	SUM(o.total_amt_usd) amt_spnt
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
HAVING SUM(o.total_amt_usd) > 30000
ORDER BY 2;
--203 accounts spent over 30,000 USD on all orders.

/*5. Which accounts spent less than 1,000 usd total across all orders?*/
SELECT
	a.name account_name,
	SUM(o.total_amt_usd) amt_spnt
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
HAVING SUM(o.total_amt_usd) < 1000
ORDER BY 2;
--3 accounts spent less than 1,000 on all orders.

/*6. Which account has spent the most with us?*/
SELECT
	a.name account,
	SUM (o.total_amt_usd) amt_spnt
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC
LIMIT 1;
--EOG Resources spent the most with total amount of 382,872.30 USD.

/*7. Which account has spent the least with us?*/
SELECT
	a.name account,
	SUM (o.total_amt_usd) amt_spnt
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2
LIMIT 1;
--Nike spent the least with total amount 390.25 USD.

/*8. Which accounts used facebook as a channel to contact customers more 
than 6 times?*/
SELECT
	a.name accounts,
	wb.channel channel,
	COUNT (*) usage_frq
FROM accounts a
JOIN web_events wb
ON a.id = wb.account_id
GROUP BY 1,2
HAVING COUNT (*) > 6 AND wb.channel = 'facebook'
ORDER BY 3 DESC;
--The query returned 46 accounts

/*9. Which account used facebook most as a channel?*/
SELECT
	a.name accounts,
	wb.channel channel,
	COUNT (*) usage_frq
FROM accounts a
JOIN web_events wb
ON a.id = wb.account_id
WHERE wb.channel = 'facebook'
GROUP BY 1,2
ORDER BY 3 DESC
LIMIT 1;
--Gilead Sciences used facebook most as a channel

/*10. Which channel was most frequently used by most accounts?*/
SELECT
	a.id,
	a.name,
	wb.channel channel,
	COUNT (*) usage_frq
FROM accounts a
JOIN web_events wb
ON a.id = wb.account_id
GROUP BY 1,2,3
ORDER BY 4 DESC
LIMIT 10;
--The Direct method was most frequently used by most account.

--DATE EXERCISES
/*1. Find the sales in terms of total dollars for all orders in each year, ordered from greatest
to least. Do you notice any trends in the yearly sales totals?*/
SELECT
	SUM(total_amt_usd) sales_usd,
	DATE_TRUNC ('Year', occurred_at) AS year
FROM orders
GROUP BY 2
ORDER BY 2 DESC;
/*The result shows that there's a yearly incrase in sales. However, 2016 recorded the highest sale.*/

/*2. Which month did Parch & Posey have the greatest sales in terms of total dollars?
Are all months evenly represented by the dataset?*/
SELECT
	SUM(total_amt_usd) sales_usd,
	DATE_PART ('Month', occurred_at) AS month
FROM orders
GROUP BY 2
ORDER BY 1 DESC;
--Parch and Posey have the highest sale in December and no sale in February.

/*3. Which year did Parch & Posey have the greatest sales in terms of total number of orders?
Are all years evenly represented by the dataset?*/
SELECT
	SUM(total) sales_qty,
	DATE_PART ('Year', occurred_at) AS year
FROM orders
GROUP BY 2
ORDER BY 1 DESC;
--Parch and Posey recorded the highest number of orders in 2016.

/*4. Which month did Parch & Posey have the greatest sales in terms of total number of orders?
Are all months evenly represented by the dataset?*/
SELECT
	SUM(total) sales_qty,
	DATE_PART ('Month', occurred_at) AS month
FROM orders
GROUP BY 2
ORDER BY 1 DESC;
--Parch and Posey have the most sale in December and no sale in February.

/*5. In which month of which year did Walmart spend the most on gloss paper in terms of dollars?*/
SELECT
	a.name account,
	SUM(o.gloss_amt_usd) total_spnt_glss,
	DATE_PART ('Month', o.occurred_at) AS month,
	DATE_PART ('Year', o.occurred_at) AS year
FROM accounts a
JOIN orders o
ON a.id = o.account_id
WHERE a.name = 'Walmart'
GROUP BY 1,3,4
ORDER BY 2 DESC;
--May 2016

--WRITING CASE STATEMENTS
SELECT
	id,
	account_id,
	standard_amt_usd/standard_qty AS unit_price
FROM orders
LIMIT 10;

SELECT
	account_id,
	CASE WHEN standard_qty = 0 OR standard_qty IS NULL THEN 0
		ELSE standard_amt_usd/standard_qty END AS unit_price
FROM orders
LIMIT 10;

SELECT
	CASE WHEN total > 500 THEN 'Over 500'
		ELSE '500 or under' END AS total_group,
	COUNT (*) AS order_count
FROM orders
GROUP BY 1;

--CASE STATEMENT EXERCISE
/*1. Write a query to display for each order, the account ID, total amount of the order, and the
level of the order - ‘Large’ or ’Small’ - depending on if the order is $3000 or more, or smaller
than $3000.*/
SELECT
	a.id account_id,
	o.total_amt_usd total_amt,
	CASE WHEN o.total_amt_usd >= 3000 THEN 'Large'
		ELSE 'Small' END AS order_level
FROM accounts a
JOIN orders o
ON a.id = o.account_id;
--Query returned 6,912 rows.

/*2. Write a query to display the number of orders in each of three categories, based on the
total number of items in each order. The three categories are: 'At Least 2000', 'Between 1000
and 2000' and 'Less than 1000'.*/
SELECT
	CASE WHEN total > 2000 THEN 'At least 2000'
		WHEN total BETWEEN 1000 AND 2000 THEN 'Between 1000 and 2000'
		ELSE 'Less than 1000' END AS order_category,
	COUNT (*) AS num_of_orders
FROM orders
GROUP BY 1;

/*3. We would like to understand 3 different levels of customers based on the amount associated
with their purchases. The top level includes anyone with a Lifetime Value (total sales of all
orders) greater than 200,000 usd. The second level is between 200,000 and 100,000 usd. The lowest
level is anyone under 100,000 usd. Provide a table that includes the level associated with each
account. You should provide the account name, the total sales of all orders for the customer, and
the level. Order with the top spending customers listed first.*/
SELECT
	a.name account_name,
	SUM(o.total_amt_usd) AS total_sales,
	CASE WHEN SUM(o.total_amt_usd) > 200000 THEN 'Top level'
		WHEN SUM(o.total_amt_usd) BETWEEN 100000 AND 200000 THEN 'Mid level'
		ELSE 'Low level' END AS cust_level
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 1;

/*4. We would now like to perform a similar calculation to the first, but we want to obtain the
total amount spent by customers only in 2016 and 2017. Keep the same levels as in the previous
question. Order with the top spending customers listed first.*/
SELECT
	a.name account_name,
	SUM(o.total_amt_usd) AS total_sales,
	CASE WHEN SUM(o.total_amt_usd) > 200000 THEN 'Top level'
		WHEN SUM(o.total_amt_usd) BETWEEN 100000 AND 200000 THEN 'Mid level'
		ELSE 'Low level' END AS cust_level
FROM accounts a
JOIN orders o
ON a.id = o.account_id
WHERE o.occurred_at BETWEEN '2016-01-01' AND '2017-12-31'
GROUP BY 1
ORDER BY 3 DESC;

/*5. We would like to identify top performing sales reps, which are sales reps associated with
more than 200 orders. Create a table with the sales rep name, the total number of orders, and a
column with top or not depending on if they have more than 200 orders. Place the top sales people
first in your final table.*/
SELECT
	sr.name sales_rep,
	COUNT(*) AS total_num_orders,
	CASE WHEN COUNT(*) > 200 THEN 'Top performing'
		ELSE 'Low performing' END AS performance
FROM sales_reps sr
JOIN accounts a
ON sr.id = a.sales_rep_id
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC;

/*6. The previous didn't account for the middle, nor the dollar amount associated with the sales.
Management decides they want to see these characteristics represented as well. We would like to
identify top performing sales reps, which are sales reps associated with more than 200 orders or
more than 750000 in total sales. The middle group has any rep with more than 150 orders or 500000
in sales. Create a table with the sales rep name, the total number of orders, total sales across
all orders, and a column with top, middle, or low depending on this criteria. Place the top sales
people based on dollar amount of sales first in your final table. You might see a few upset sales
people by this criteria!*/
SELECT
	sr.name sales_rep,
	COUNT(*) AS total_num_orders,
	SUM (o.total_amt_usd) AS total_sales,
	CASE WHEN COUNT(*) > 200 OR SUM (o.total_amt_usd) > 750000 THEN 'Top performing'
		WHEN COUNT(*) BETWEEN 150 AND 200 OR SUM (o.total_amt_usd) BETWEEN 500000 AND 750000 THEN 'Mid performing'
		ELSE 'Low performing' END AS performance
FROM sales_reps sr
JOIN accounts a
ON sr.id = a.sales_rep_id
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC;

--WORKING WITH SUBQUERIES
/* Example: We want to find the average number of events for each day for each channel.
The first table will provide us the number of events for each day and channel, and then we will
need to average these values together using a second query*/
SELECT
	channel,
	AVG(events) AS avg_event
FROM (SELECT
		DATE_TRUNC('day', occurred_at) AS day,
		channel,
		COUNT(*) AS events
	FROM web_events
	GROUP BY 1,2) sub
GROUP BY 1;

--SUBQUERIES 1st EXERCISE
/*1. On which day-channel pair did the most events occur?*/
SELECT
	DATE_TRUNC('day', occurred_at) AS day,
	channel,
	COUNT(*) AS event
FROM web_events
GROUP BY 1,2
ORDER BY 3 DESC;

/*2. Return all orders that occurred in the month as the first ever order at Parch and Posey, and
then pull the average for each type of paper qty in this month and the total amount spent on orders.*/
SELECT
	AVG(standard_qty) AS avg_std,
	AVG(gloss_qty) AS avg_gls,
	AVG(poster_qty) AS avg_pst,
	SUM(total_amt_usd) AS total_amt_spnt
FROM	(SELECT *
		FROM orders
		WHERE DATE_TRUNC('month', occurred_at) =
				(SELECT
					DATE_TRUNC('month', MIN(occurred_at)) AS min_date
				FROM orders)
		ORDER BY occurred_at) sub;
/*The above query can also be written as below. Also, the 'ORDER BY' statement in the subquery
above is not entirely necessary.*/
SELECT
	AVG(standard_qty) AS avg_std,
	AVG(gloss_qty) AS avg_gls,
	AVG(poster_qty) AS avg_pst,
	SUM(total_amt_usd) AS total_amt_spnt
FROM orders
WHERE DATE_TRUNC('month', occurred_at) =
		(SELECT
			DATE_TRUNC('month', MIN(occurred_at)) AS min_date
		FROM orders);

--SUBQUERIES 2nd EXERCISE
/*1. Provide the names of the sales_rep in each region with the largest amount of total_amt_usd
sales.*/
SELECT
	t1.sales_rep,
	t2.region,
	t2.highest_sale	
FROM
(SELECT
	region,
	MAX(sales) AS highest_sale
 FROM (SELECT
			sr.name sales_rep,
			r.name region,
			SUM(o.total_amt_usd) AS sales
		FROM region r
		JOIN sales_reps sr
		ON r.id = sr.region_id
		JOIN accounts a
		ON sr.id = a.sales_rep_id
		JOIN orders o
		ON o.account_id = a.id
		GROUP BY 1,2
		ORDER BY 3 DESC) t1
 GROUP BY 1) t2
JOIN (SELECT
			sr.name sales_rep,
			r.name region,
			SUM(o.total_amt_usd) AS sales
		FROM region r
		JOIN sales_reps sr
		ON r.id = sr.region_id
		JOIN accounts a
		ON sr.id = a.sales_rep_id
		JOIN orders o
		ON o.account_id = a.id
		GROUP BY 1,2)t1
ON t1.sales = t2.highest_sale
ORDER BY 3 DESC;

/*2. For the region with the largest (sum) of sales total_amt_usd, how many total (count) orders were placed?*/
SELECT
	t2.region,
	t1.sales,
	t2.total_order_count
FROM
	(SELECT
		r.name region,
		SUM(o.total_amt_usd) AS sales
	FROM region r
	JOIN sales_reps sr
	ON r.id = sr.region_id
	JOIN accounts a
	ON sr.id = a.sales_rep_id
	JOIN orders o
	ON o.account_id = a.id
	GROUP BY 1
	ORDER BY 2 DESC
	LIMIT 1)t1
JOIN
	(SELECT
		r.name region,
		COUNT(*) AS total_order_count
	FROM region r
	JOIN sales_reps sr
	ON r.id = sr.region_id
	JOIN accounts a
	ON sr.id = a.sales_rep_id
	JOIN orders o
	ON o.account_id = a.id
	GROUP BY 1
	ORDER BY 2 DESC
	LIMIT 1)t2
ON t2.region = t1.region;

/*3. How many accounts had more total purchases than the account name which has bought the most standard_qty paper throughout their lifetime as a
customer?*/
SELECT COUNT(*) AS NAPCMHSQP
FROM
	(SELECT
		t1.account_name,
		t1.total_items_ordered
	FROM
		(SELECT
			a.name account_name,
			SUM(o.total) total_items_ordered
		FROM accounts a
		JOIN orders o
		ON a.id = o.account_id
		GROUP BY 1
		ORDER BY 2 DESC) t1
	JOIN
		(SELECT
			a.name account_name,
			SUM(o.standard_qty) total_stdqty_ordered
		FROM accounts a
		JOIN orders o
		ON a.id = o.account_id
		GROUP BY 1
		ORDER BY 2 DESC) t2
	ON t1.account_name = t2.account_name
	WHERE t1.total_items_ordered >(SELECT
									t2.total_purchase
								   FROM 
									(SELECT
										a.name account_name,
										SUM(o.standard_qty) total_stdqty_ordered,
									 	SUM(o.total) total_purchase
									FROM accounts a
									JOIN orders o
									ON a.id = o.account_id
									GROUP BY 1
									ORDER BY 2 DESC
									LIMIT 1) t2)
	ORDER BY 2 DESC)t3;
--NAWMPTCMH: Number of Accounts with more total Purchase than 'Core Mark Holdings' Standard Quantity Paprt purchase = 3.

/*4. For the customer that spent the most (in total over their lifetime as a customer) total_amt_usd, how many web_events did they have for each
channel?*/
SELECT
	t1.account_name,
	t2.channel,
	t2.events
FROM
	(SELECT
		a.name account_name,
		SUM(o.total_amt_usd) AS total_spnt
	FROM accounts a
	JOIN orders o
	ON a.id = o.account_id
	GROUP BY 1
	ORDER BY 2 DESC
	LIMIT 1) t1
JOIN
	(SELECT
		a.name account_name,
		wb.channel channel,
		COUNT(*) AS events
	FROM web_events wb
	JOIN accounts a
	ON wb.account_id = a.id
	GROUP BY 1,2) t2
ON t1.account_name = t2.account_name;

/*5. What is the lifetime average amount spent in terms of total_amt_usd for the top 10 total spending accounts?*/
SELECT
	AVG(total_spnt) AS avg_amt_spnt
FROM
	(SELECT
		a.name account_name,
		SUM(o.total_amt_usd) AS total_spnt
	FROM accounts a
	JOIN orders o
	ON a.id = o.account_id
	GROUP BY 1
	ORDER BY 2 DESC
	LIMIT 10) t1;
	
/*6. What is the lifetime average amount spent in terms of total_amt_usd, including only the companies that spent more per order, on average, than the average of
all orders.*/
SELECT
	AVG(avg_amnt)
FROM
	(SELECT
		account_id id,
		AVG(total_amt_usd) AS avg_amnt
	FROM
		orders
	GROUP BY 1
	HAVING AVG(total_amt_usd) >
								(SELECT
									AVG(total_amt_usd) AS life_time_avg_spnt
								FROM orders))t1;

/*Use the WITH statement to answer all the questions above.*/
/*1. Provide the names of the sales_rep in each region with the largest amount of total_amt_usd sales.*/
WITH 
t1 AS 
(SELECT
	sr.name sales_rep,
	r.name region,
	SUM(o.total_amt_usd) sales
FROM sales_reps sr
JOIN region r
ON sr.region_id = r.id
JOIN accounts a
ON a.sales_rep_id = sr.id
JOIN orders o
ON o.account_id = a.id
GROUP BY 1,2
ORDER BY 3 DESC),

t2 AS
(SELECT
	region,
	MAX(sales) as hghst_sales
FROM (
	SELECT
		sr.name sales_rep,
		r.name region,
		SUM(o.total_amt_usd) sales
	FROM sales_reps sr
	JOIN region r
	ON sr.region_id = r.id
	JOIN accounts a
	ON a.sales_rep_id = sr.id
	JOIN orders o
	ON o.account_id = a.id
	GROUP BY 1,2
	ORDER BY 3 DESC) t1
GROUP BY 1)
	
SELECT
	t1.sales_rep sales_rep,
	t1.region region,
	t2.hghst_sales hghst_sales
FROM t1
JOIN t2
ON t1.sales = t2.hghst_sales AND t1.region = t2.region;

/*2. For the region with the largest (sum) of sales total_amt_usd, how many total (count) orders were placed?*/
WITH
t1 AS
(SELECT
	r.name region,
	SUM(o.total_amt_usd) sales
FROM sales_reps sr
JOIN region r
ON sr.region_id = r.id
JOIN accounts a
ON a.sales_rep_id = sr.id
JOIN orders o
ON o.account_id = a.id
GROUP BY 1
ORDER BY 2 DESC
LIMIT 1),

t2 AS
(SELECT
	r.name region,
	COUNT(*) sales
FROM sales_reps sr
JOIN region r
ON sr.region_id = r.id
JOIN accounts a
ON a.sales_rep_id = sr.id
JOIN orders o
ON o.account_id = a.id
GROUP BY 1
ORDER BY 2 DESC)

SELECT
	t1.region region,
	t2.sales count_of_sales
FROM t1
JOIN t2
ON t1.region = t2.region;

/*3. How many accounts had more total purchases than the account name which has bought the most standard_qty paper throughout their lifetime as a customer?*/
WITH
t1 AS
(SELECT
	a.name account_name,
	SUM(o.standard_qty) total_stdqty_ordered,
	SUM(o.total) total_items_ordered
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC),

t2 AS
(SELECT
	a.name account_name,
	SUM(o.total) total_items_ordered
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC),

t3 AS
(SELECT
	t1.account_name
FROM t1
JOIN t2
ON t1.account_name = t2.account_name
WHERE t2.total_items_ordered > (SELECT total_items_ordered
								FROM (SELECT
										a.name account_name,
										SUM(o.standard_qty) total_stdqty_ordered,
										SUM(o.total) total_items_ordered
									FROM accounts a
									JOIN orders o
									ON a.id = o.account_id
									GROUP BY 1
									ORDER BY 2 DESC
									LIMIT 1)sub))

SELECT COUNT(*) FROM t3;

/*5. What is the lifetime average amount spent in terms of total_amt_usd for the top 10 total spending accounts?*/
WITH
t1 AS
(SELECT
	a.name accounts,
	SUM(o.total_amt_usd) tot_amt_spnt
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY 1
ORDER BY 2 DESC
LIMIT 10)

SELECT
	AVG(tot_amt_spnt)
FROM t1;

/*6. What is the lifetime average amount spent in terms of total_amt_usd, including only the companies that spent more per order, on average, than the average of
all orders.*/
WITH
t1 AS
(SELECT
	AVG(total_amt_usd) life_time_spnt
FROM orders),

t2 AS
(SELECT
	id,
	AVG(total) order_avg
FROM orders
GROUP BY 1
HAVING AVG(total) > (SELECT * FROM t1))

SELECT AVG(order_avg) FROM t2;

--LEFT AND RIGHT QUIZ

/*1. In the accounts table, there is a column holding the website for each company. The last three digits specify what type of web address they are using.
A list of extensions (and pricing) is provided here. Pull these extensions and provide how many of each website type exist in the accounts table.*/
SELECT
	RIGHT(website, 3) AS domain,
	COUNT (*) num_companies
FROM accounts
GROUP BY 1;

/*2. There is much debate about how much the name (or even the first letter of a company name) matters. Use the accounts table to pull the first letter of each
company name to see the distribution of company names that begin with each letter (or number).*/
SELECT
	LEFT(UPPER(name), 1) AS first_letter,
	COUNT (*) AS num_companies
FROM accounts
GROUP BY 1
ORDER BY 2 DESC;

/*3. Use the accounts table and a CASE statement to create two groups: one group of company names that start with a number and a second group of those company
names that start with a letter. What proportion of company names start with a letter?*/
SELECT
    CASE
        WHEN LEFT(name, 1) BETWEEN '0' AND '9' THEN 'Starts with Number'
        ELSE 'Starts with Letter'
    END AS company_name,
    COUNT(*) AS proportion
FROM accounts
GROUP BY 1;

SELECT SUM(num) nums, SUM(letter) letters
FROM (SELECT name, CASE WHEN LEFT(UPPER(name), 1) IN ('0','1','2','3','4','5','6','7','8','9') 
                          THEN 1 ELSE 0 END AS num, 
            CASE WHEN LEFT(UPPER(name), 1) IN ('0','1','2','3','4','5','6','7','8','9') 
                          THEN 0 ELSE 1 END AS letter
         FROM accounts) t1;

/*4. Consider vowels as a, e, i, o, and u. What proportion of company names start with a vowel, and what percent start with anything else?*/
SELECT
	CASE
		WHEN LEFT(name, 1) IN ('A', 'E', 'I', 'O', 'U') THEN 'Starts with vowel'
		ELSE 'Starts with anything else'
	END AS company_name,
	COUNT (*) AS proportion
FROM accounts
GROUP BY 1
ORDER BY 2 DESC;

SELECT SUM(vowels) vowels, SUM(other) other
FROM (SELECT name, CASE WHEN LEFT(UPPER(name), 1) IN ('A','E','I','O','U') 
                           THEN 1 ELSE 0 END AS vowels, 
             CASE WHEN LEFT(UPPER(name), 1) IN ('A','E','I','O','U') 
                          THEN 0 ELSE 1 END AS other
            FROM accounts) t1;

--POSTION AND STRPOS
/*1. Use the accounts table to create first and last name columns that hold the first and last names for the primary_poc.*/
SELECT
	primary_poc,
	LEFT (primary_poc, POSITION(' ' IN (primary_poc))-1) AS first_name,
	SUBSTRING (primary_poc FROM POSITION(' ' IN (primary_poc))+1) AS last_name
FROM accounts;

SELECT
	primary_poc,
	LEFT (primary_poc, POSITION(' ' IN (primary_poc))-1) AS first_name,
	RIGHT (primary_poc, LENGTH(primary_poc) - POSITION(' ' IN (primary_poc))) AS last_name
FROM accounts;

/*2. Now see if you can do the same thing for every rep name in the sales_reps table. Again provide first and last name columns.*/
WITH
t1 AS
(SELECT
	name,
	LEFT (name, STRPOS(name, ' ')-1) AS first_name,
	RIGHT (name, LENGTH(name) - STRPOS(name, ' ')) AS last_name
FROM sales_reps)

--CONCATINATION (please comment one of the queries below to allow the order run with the CTE above)
SELECT
	first_name ||' '|| last_name AS full_name
FROM t1;

/*SELECT
	CONCAT(first_name, ' ', last_name) AS full_name_alt
FROM t1;;*/

--CONCATINATION EXERCISE
/*1. Each company in the accounts table wants to create an email address for each primary_poc. The email address should be the first name of the primary_poc . 
last name primary_poc @ company name .com.*/
WITH
t1 AS
(SELECT
	name company,
	LEFT(primary_poc, STRPOS(primary_poc, ' ')-1) AS first_name,
	RIGHT(primary_poc, LENGTH(primary_poc) - STRPOS(primary_poc, ' ')) AS last_name
FROM accounts)

SELECT
	first_name,
	last_name,
	company,
	LOWER(first_name||'.'||last_name||'@'||company||'.com') AS email
FROM t1;

/*2. You may have noticed that in the previous solution some of the company names include spaces, which will certainly not work in an email address.
See if you can create an email address that will work by removing all of the spaces in the account name, but otherwise your solution should be just as in question 1.*/
WITH
t1 AS
(SELECT
	name company,
	LEFT(primary_poc, STRPOS(primary_poc, ' ')-1) AS first_name,
	RIGHT(primary_poc, LENGTH(primary_poc) - STRPOS(primary_poc, ' ')) AS last_name
FROM accounts)

SELECT
	first_name,
	last_name,
	company,
	LOWER(first_name||'.'||last_name||'@'||REPLACE(company, ' ', '')||'.com') AS email
FROM t1;

/*3. We would also like to create an initial password, which they will change after their first log in.
The first password will be the first letter of the primary_poc's first name (lowercase), then the last letter of their first name (lowercase),
the first letter of their last name (lowercase), the last letter of their last name (lowercase), the number of letters in their first name, the number of letters
in their last name, and then the name of the company they are working with, all capitalized with no spaces.*/
WITH
t1 AS
(SELECT
	name company,
	LEFT(primary_poc, STRPOS(primary_poc, ' ')-1) AS first_name,
	RIGHT(primary_poc, LENGTH(primary_poc) - STRPOS(primary_poc, ' ')) AS last_name
FROM accounts)

SELECT
	first_name,
	last_name,
	company,
	LOWER(first_name||'.'||last_name||'@'||RTRIM((REPLACE(company, ' ', '')), '.')||'.com') AS email,
	LEFT(LOWER(first_name), 1)||
	RIGHT(LOWER(first_name), 1)||
	LEFT(LOWER(last_name), 1)||
	RIGHT(LOWER(last_name), 1)||
	LENGTH(first_name)||
	LENGTH(last_name)||
	REPLACE(UPPER(company), ' ', '') AS password
FROM t1;

--COALESCE EXERCISE
--table 1
SELECT *
FROM accounts a
LEFT JOIN orders o
ON a.id = o.account_id
WHERE o.total IS NULL;

/*1. Use COALESCE to fill in the accounts.id column with the account.id for the NULL value for table 1.*/
SELECT
	COALESCE(o.id, a.id) filled_id,
	a.name,
	a.website,
	a.lat,
	a.long,
	a.primary_poc,
	a.sales_rep_id,
	o.*
FROM accounts a
LEFT JOIN orders o
ON a.id = o.account_id
WHERE o.total IS NULL;

/*2. Use COALESCE to fill in the orders.account_id column with the account.id for the NULL value for the table in 1.*/
SELECT
	COALESCE(o.id, a.id) filled_id,
	a.name,
	a.website,
	a.lat,
	a.long,
	a.primary_poc,
	a.sales_rep_id,
	COALESCE(o.account_id, a.id) account_id,
	o.occurred_at,
	o.standard_qty,
	o.gloss_qty,
	o.poster_qty,
	o.total,
	o.standard_amt_usd,
	o.gloss_amt_usd,
	o.poster_amt_usd,
	o.total_amt_usd
FROM accounts a
LEFT JOIN orders o
ON a.id = o.account_id
WHERE o.total IS NULL;

/*3. Use COALESCE to fill in each of the qty and usd columns with 0 for the table in 1.*/
SELECT
	COALESCE(o.id, a.id) filled_id,
	a.name,
	a.website,
	a.lat,
	a.long,
	a.primary_poc,
	a.sales_rep_id,
	COALESCE(o.account_id, a.id) account_id,
	o.occurred_at,
	COALESCE (o.standard_qty, 0) std_qty,
	COALESCE (o.gloss_qty, 0) gls_qty,
	COALESCE (o.poster_qty, 0) pst_qty,
	o.total,
	COALESCE (o.standard_amt_usd, 0) std_amt_usd,
	COALESCE (o.gloss_amt_usd, 0) gls_amt_usd,
	COALESCE (o.poster_amt_usd, 0) pst_amt_usd,
	o.total_amt_usd
FROM accounts a
LEFT JOIN orders o
ON a.id = o.account_id
WHERE o.total IS NULL;

/*4. Run the query in 1 with the WHERE removed and COUNT the number of ids.*/
SELECT COUNT(a.id)
FROM accounts a
LEFT JOIN orders o
ON a.id = o.account_id;

/*5. Run the query in 4, but with the COALESCE function used in questions 2 and 3.*/
SELECT
	COALESCE(o.id, a.id) filled_id,
	a.name,
	a.website,
	a.lat,
	a.long,
	a.primary_poc,
	a.sales_rep_id,
	COALESCE(o.account_id, a.id) account_id,
	o.occurred_at,
	COALESCE (o.standard_qty, 0) std_qty,
	COALESCE (o.gloss_qty, 0) gls_qty,
	COALESCE (o.poster_qty, 0) pst_qty,
	o.total,
	COALESCE (o.standard_amt_usd, 0) std_amt_usd,
	COALESCE (o.gloss_amt_usd, 0) gls_amt_usd,
	COALESCE (o.poster_amt_usd, 0) pst_amt_usd,
	o.total_amt_usd
FROM accounts a
LEFT JOIN orders o
ON a.id = o.account_id;

--WINDOWS FUNCTION
SELECT
	standard_qty,
	SUM(standard_qty) OVER (ORDER BY occurred_at) AS running_total
FROM orders;

SELECT
	standard_qty,
	DATE_TRUNC ('month', occurred_at) AS month,
	SUM (standard_qty) OVER (PARTITION BY DATE_TRUNC ('month', occurred_at) ORDER BY occurred_at) AS running_total
FROM orders;

/*1. Create a running total of standard_amt_usd (in the orders table) over order time with no date truncation.*/
SELECT
	standard_amt_usd,
	SUM (standard_amt_usd) OVER (ORDER BY occurred_at) AS running_total
FROM orders;

/*2. Modify the above query, but date truncate occurred_at by year and partition by that same year-truncated occurred_at variable.*/
SELECT
	standard_amt_usd,
	DATE_TRUNC ('year', occurred_at) AS year,
	SUM (standard_amt_usd) OVER (PARTITION BY (DATE_TRUNC ('year', occurred_at)) ORDER BY occurred_at) AS running_total
FROM orders;

--ROW NUMBER () and RANK
SELECT
	id,
	account_id,
	occurred_at,
	ROW_NUMBER() OVER (ORDER BY occurred_at) AS row_num
FROM orders;

SELECT
	id,
	account_id,
	occurred_at,
	ROW_NUMBER() OVER (PARTITION BY account_id ORDER BY occurred_at) AS row_num
FROM orders;

SELECT
	id,
	account_id,
	occurred_at,
	RANK() OVER (PARTITION BY account_id ORDER BY occurred_at) AS row_num
FROM orders;

SELECT
	id,
	account_id,
	DATE_TRUNC ('month', occurred_at) AS occurred_at,
	RANK() OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS row_num
FROM orders;

SELECT
	id,
	account_id,
	DATE_TRUNC ('month', occurred_at) AS occurred_at,
	DENSE_RANK() OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS row_num
FROM orders;

--EXERCISE
/*Select the id, account_id, and total variable from the orders table, then create a column called total_rank that ranks this total amount of paper ordered
(from highest to lowest) for each account using a partition.*/
SELECT
	id,
	account_id,
	total,
	RANK() OVER (PARTITION BY account_id ORDER BY total DESC) total_rank
FROM orders;

--USING MULTIPLE AGGREGATE FUNCTION IN THE WINDOWS FUNCTION
SELECT
	id,
	account_id,
	standard_qty,
	DATE_TRUNC ('month', occurred_at) AS month,
	DENSE_RANK() OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS dense_rank,
	SUM(standard_qty) OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS sum_standard_qty,
	COUNT(standard_qty) OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS count_standard_qty,
	AVG(standard_qty) OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS avg_standard_qty,
	MIN(standard_qty) OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS min_standard_qty,
	MAX(standard_qty) OVER (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at)) AS max_standard_qty
FROM orders;
/*Explanation: the data is ranked by date (truncated by month), partitioned by account_id and ordered by date trunc of month. Sum is a running total of the standard_qty
paper ordered but it hass the same value in rows 2 and 3 because they both have the same rank number, hence treated the same. Same goes for count. Avg is sum/count.
Min picks the lowest value in the first row until the next lowest value in the row partition, the same works for max.*/

SELECT id,
       account_id,
       standard_qty,
       DATE_TRUNC('month', occurred_at) AS month,
       DENSE_RANK() OVER (PARTITION BY account_id) AS dense_rank,
       SUM(standard_qty) OVER (PARTITION BY account_id) AS sum_std_qty,
       COUNT(standard_qty) OVER (PARTITION BY account_id) AS count_std_qty,
       AVG(standard_qty) OVER (PARTITION BY account_id) AS avg_std_qty,
       MIN(standard_qty) OVER (PARTITION BY account_id) AS min_std_qty,
       MAX(standard_qty) OVER (PARTITION BY account_id) AS max_std_qty
FROM orders;

/*To write multiple window functions in the same query using the same window (such as the above), we can siplify it by giving the window function an alias
which normally goes between the where clause and the group by clause.*/

SELECT
	id,
	account_id,
	standard_qty,
	DATE_TRUNC ('month', occurred_at) AS month,
	DENSE_RANK() OVER account_month_window AS dense_rank,
	SUM(standard_qty) OVER account_month_window AS sum_standard_qty,
	COUNT(standard_qty) OVER account_month_window AS count_standard_qty,
	AVG(standard_qty) OVER account_month_window AS avg_standard_qty,
	MIN(standard_qty) OVER account_month_window AS min_standard_qty,
	MAX(standard_qty) OVER account_month_window AS max_standard_qty
FROM orders
WINDOW account_month_window AS (PARTITION BY account_id ORDER BY DATE_TRUNC ('month', occurred_at));

/*LAG and LEAD: these functions are used to compare rows to preceeding or following rows. The LAG function pulls values from the previouse rows and LEAD
pulls values from the following rows.*/
SELECT
	account_id,
	standard_sum,
	LAG(standard_sum) OVER (ORDER BY standard_sum) AS lag_std,
	LEAD(standard_sum) OVER (ORDER BY standard_sum) AS lead_std
FROM
	(SELECT
		account_id,
		SUM(standard_qty) AS standard_sum
	FROM orders
	GROUP BY 1) SUB;
	
/* The LAG and LEAD functions are very useful for calculating diffrences between 2 rows*/
SELECT
	account_id,
	standard_sum,
	LAG(standard_sum) OVER (ORDER BY standard_sum) AS lag_std,
	LEAD(standard_sum) OVER (ORDER BY standard_sum) AS lead_std,
	standard_sum - LAG(standard_sum) OVER (ORDER BY standard_sum) AS lag_diff,
	LEAD(standard_sum) OVER (ORDER BY standard_sum) - standard_sum AS lead_diff
FROM
	(SELECT
		account_id,
		SUM(standard_qty) AS standard_sum
	FROM orders
	GROUP BY 1) SUB;
	
/*EXERCISE: Imagine you're an analyst at Parch & Posey and you want to determine how the current order's total revenue ("total" meaning from sales of all types
of paper) compares to the next order's total revenue.*/

SELECT
	occurred_at,
	revenue,
	LEAD(revenue) OVER (ORDER BY occurred_at) AS lead_rev,
	LEAD(revenue) OVER (ORDER BY occurred_at) - revenue AS revenue_diff
FROM(
	SELECT
		occurred_at,
		SUM(total_amt_usd) AS revenue
	FROM orders 
	GROUP BY 1) SUB;
	
--PERCENTILES
SELECT
	id,
	account_id,
	occurred_at,
	standard_qty,
	NTILE(4) OVER (ORDER BY standard_qty) AS quartile,
	NTILE(5) OVER (ORDER BY standard_qty) AS qunatile,
	NTILE(100) OVER (ORDER BY standard_qty) AS percentile
FROM orders
ORDER BY standard_qty DESC;

--EXERCISE
/*1. Use the NTILE functionality to divide the accounts into 4 levels in terms of the amount of standard_qty for their orders. Your resulting table should have
the account_id, the occurred_at time for each order, the total amount of standard_qty paper purchased, and one of four levels in a standard_quartile column.*/
SELECT
	account_id,
	occurred_at,
	standard_qty,
	NTILE(4) OVER (PARTITION BY account_id ORDER BY standard_qty) AS standard_quartile
FROM orders
ORDER BY account_id DESC;

/*2. Use the NTILE functionality to divide the accounts into two levels in terms of the amount of gloss_qty for their orders. Your resulting table should have
the account_id, the occurred_at time for each order, the total amount of gloss_qty paper purchased, and one of two levels in a gloss_half column.*/
SELECT
	account_id,
	occurred_at,
	gloss_qty,
	NTILE(4) OVER (PARTITION BY account_id ORDER BY gloss_qty) AS gloss_quartile
FROM orders
ORDER BY account_id DESC;

/*3. Use the NTILE functionality to divide the orders for each account into 100 levels in terms of the amount of total_amt_usd for their orders. Your resulting
table should have the account_id, the occurred_at time for each order, the total amount of total_amt_usd paper purchased, and one of 100 levels in a
total_percentile column.*/
SELECT
	account_id,
	occurred_at,
	total_amt_usd,
	NTILE(100) OVER (PARTITION BY account_id ORDER BY total_amt_usd) AS amt_percentile
FROM orders
ORDER BY account_id DESC;

--FULL OUTER JOINS
/*1. Usiing the FULL JOIN function, check all accounts that do not have a sales rep and all sales reps without an account.*/
SELECT
	a.name account,
	sr.name sales_rep
FROM accounts a
FULL JOIN sales_reps sr
ON a.sales_rep_id = sr.id
WHERE a.sales_rep_id IS NULL OR sr.id IS NULL;
--There are no accounts without a sales rep or sales reps without an account.

--INEQUALITY JOINS
SELECT
	o.id,
	o.occurred_at AS order_date,
	wb.*	
FROM orders o
LEFT JOIN web_events wb
	ON wb.account_id = o.account_id
	AND wb.occurred_at < o.occurred_at
WHERE DATE_TRUNC('month', o.occurred_at) = (SELECT
	DATE_TRUNC('month', MIN(occurred_at))
FROM orders)
ORDER BY o.account_id, o.occurred_at;
	
/*Exercise: Write a query that left joins the accounts table and the sales_reps tables on each sale rep's ID number and joins it using the < comparison operator
on accounts.primary_poc and sales_reps.name.*/
SELECT
	a.name account_name,
	a.primary_poc,
	sr.name sales_rep
FROM accounts a
LEFT JOIN sales_reps sr
ON a.sales_rep_id = sr.id
AND a.primary_poc < sr.name;

--SELF JOINS
SELECT
	o1.id AS o1_id,
	o1.account_id AS o1_account_id,
	o1.occurred_at AS o1_occurred_at,
	o2.id AS o2_id,
	o2.account_id AS o2_account_id,
	o2.occurred_at AS o2_occurred_at
FROM orders o1
LEFT JOIN orders o2
ON o1.account_id = o2.account_id
AND o2.occurred_at > o1.occurred_at
AND o2.occurred_at <= o1.occurred_at + INTERVAL '28 Days'
ORDER BY o1.account_id, o1.occurred_at;

/*Modify the query from the previous video, which is pre-populated in the SQL Explorer below, to perform the same interval
analysis except for the web_events table. Also:
1. Change the interval to 1 day to find those web events that occurred after, but not more than 1 day after, another web event
2. Add a column for the channel variable in both instances of the table in your query*/

SELECT
	wb1.id AS wb1_id,
	wb1.account_id AS wb1_account_id,
	wb1.occurred_at AS wb1_occurred_at,
	wb1.channel AS wb1_channel,
	wb2.id AS wb2_id,
	wb2.account_id AS wb2_account_id,
	wb2.occurred_at AS wb2_occurred_at,
	wb2.channel AS wb2_channel
FROM web_events wb1
LEFT JOIN web_events wb2
ON wb1.account_id = wb2.account_id
AND wb2.occurred_at > wb1.occurred_at
AND wb2.occurred_at <= wb1.occurred_at + INTERVAL '1 Day'
ORDER BY wb1.account_id, wb2.occurred_at;

--UNION

SELECT * FROM web_events
UNION
SELECT * FROM web_events;

--Pretreating tables before doing a unioin.

SELECT * FROM web_events
WHERE channel = 'facebook'
UNION ALL
SELECT * FROM web_events;

--Performing operations on union

SELECT
	channel,
	COUNT(*) AS sessions
FROM (
	SELECT * FROM web_events
	UNION ALL
	SELECT * FROM web_events) sub
GROUP BY 1;

--Using a CTE for the subquery makes the query more readable.
WITH t1 AS
(SELECT * FROM web_events
	UNION ALL
	SELECT * FROM web_events)
	
SELECT
	channel,
	COUNT (*) AS sessions
FROM t1
GROUP BY 1;

/*Write a query that uses UNION ALL on two instances (and selecting all columns) of the accounts table. Then inspect the results
and answer the subsequent quiz.*/
SELECT * FROM accounts
WHERE name = 'Walmart'
UNION ALL
SELECT * FROM accounts
WHERE name = 'Disney';
--The above query can also be written as:
SELECT * FROM accounts
WHERE name = 'Walmart' OR name = 'Disney';

WITH t1 AS (
SELECT * FROM accounts
UNION ALL
SELECT * FROM accounts)

SELECT
	name,
	COUNT (*) AS frq
FROM t1
GROUP BY 1;

--Performance tuning
EXPLAIN
WITH t1 AS (
SELECT * FROM accounts
UNION ALL
SELECT * FROM accounts)

SELECT
	name,
	COUNT (*) AS frq
FROM t1
GROUP BY 1;